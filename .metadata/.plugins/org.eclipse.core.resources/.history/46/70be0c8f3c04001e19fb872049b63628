#ifndef INC_RGB_H_
#define INC_RGB_H_

// PRIVATE INCLUDE ================================================================================

#include <WS2812B.h>
#include <math.h>

// PRIVATE FUNCTION PROTOTYPE =====================================================================

uint32_t LERP(uint32_t start, uint32_t end, float t);
void RGB_Rainbow(void);

// USER CODE ======================================================================================

void RGB_Rainbow(void) {
	static uint8_t hue = 0;
	static uint8_t reverse = 0;

	uint32_t time = 0;
	if (HAL_GetTick() - time >= 50) {
		time = HAL_GetTick() + 50;

		// Update hue
		if (!reverse) {
			hue++;
			if (hue >= 255) {
				reverse = 1;
			}
		} else {
			hue--;
			if (hue <= 0) {
				reverse = 0;
			}
		}

		// Calculate color gradient
		uint32_t colorStart = hue;
		uint32_t colorEnd = (hue + 85) % 255;

		// Set LED colors based on color gradient
		for (int i = 0; i < MAX_LED; i++) {
			uint32_t color = LERP(colorStart, colorEnd, (float) i / MAX_LED);
			Set_LED(i, color, 255 - color, 0);
		}

		// Send LED data to update colors
		WS2812_Send();
		Set_Brightness(45);
	}
}

uint32_t LERP(uint32_t start, uint32_t end, float t) {
	uint8_t startR = (start >> 16) & 0xFF;
	uint8_t startG = (start >> 8) & 0xFF;
	uint8_t startB = start & 0xFF;

	uint8_t endR = (end >> 16) & 0xFF;
	uint8_t endG = (end >> 8) & 0xFF;
	uint8_t endB = end & 0xFF;

	uint8_t interpolatedR = (uint8_t) ((1 - t) * startR + t * endR);
	uint8_t interpolatedG = (uint8_t) ((1 - t) * startG + t * endG);
	uint8_t interpolatedB = (uint8_t) ((1 - t) * startB + t * endB);

	return (interpolatedR << 16) | (interpolatedG << 8) | interpolatedB;
}

void RGB_Rainbow_Time(void) {
	static uint32_t startTime = 0;
	static const uint32_t transitionDuration = 5000; // Transition duration in milliseconds

	if (HAL_GetTick() - startTime >= transitionDuration) {
		startTime = HAL_GetTick();
	}

	// Calculate time elapsed in the current transition
	uint32_t elapsed = HAL_GetTick() - startTime;

	// Calculate the normalized progress (0.0 to 1.0) within the transition
	float progress = (float) elapsed / transitionDuration;

	// Calculate the hue angle based on the progress
	float hueAngle = 360.0f * progress;

	// Set LED colors based on the hue angle
	for (int i = 0; i < MAX_LED; i++) {
		// Calculate the hue value for the current LED
		float ledHue = hueAngle + (i * (360.0f / MAX_LED));

		// Convert hue to RGB using HSV color model
		float huePrime = fmodf(ledHue / 60.0f, 6.0f);
		float chroma = 1.0f;
		float x = chroma * (1.0f - fabsf(fmodf(huePrime, 2.0f) - 1.0f));

		float red, green, blue;

		if (huePrime >= 0.0f && huePrime < 1.0f) {
			red = chroma;
			green = x;
			blue = 0.0f;
		} else if (huePrime >= 1.0f && huePrime < 2.0f) {
			red = x;
			green = chroma;
			blue = 0.0f;
		} else if (huePrime >= 2.0f && huePrime < 3.0f) {
			red = 0.0f;
			green = chroma;
			blue = x;
		} else if (huePrime >= 3.0f && huePrime < 4.0f) {
			red = 0.0f;
			green = x;
			blue = chroma;
		} else if (huePrime >= 4.0f && huePrime < 5.0f) {
			red = x;
			green = 0.0f;
			blue = chroma;
		} else {
			red = chroma;
			green = 0.0f;
			blue = x;
		}

		// Scale RGB values to 0-255 range
		uint8_t r = (uint8_t) (red * 255);
		uint8_t g = (uint8_t) (green * 255);
		uint8_t b = (uint8_t) (blue * 255);

		// Set LED color
		Set_LED(i, r, g, b);
	}

	// Send LED data to update colors
	WS2812_Send();

	// Set brightness
	Set_Brightness(45);
}

#endif /* INC_RGB_H_ */
