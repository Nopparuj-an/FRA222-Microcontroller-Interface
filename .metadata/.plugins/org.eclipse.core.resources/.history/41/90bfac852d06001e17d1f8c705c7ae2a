#ifndef INC_RGB_H_
#define INC_RGB_H_

// PRIVATE INCLUDE ================================================================================

#include <WS2812B.h>
#include <math.h>
#include <MainLogic.h>

// PRIVATE FUNCTION PROTOTYPE =====================================================================

void RGB_logic(MachineState state, uint8_t point, uint8_t emergency);
void RGB_Rainbow();
void RGB_Power_Status();
void RGB_Bootup();
void RGB_BreathingPattern();
void RGB_BlinkGreenTwice();

// PRIVATE VARIABLE ===============================================================================

uint32_t LEDtime = 0;
MachineState laststate = MSidle;

// USER CODE ======================================================================================

void RGB_logic(MachineState state, uint8_t point, uint8_t emergency) {
	// Run on 200 Hz
	static uint32_t timestamp;
	if (HAL_GetTick() - timestamp < 5) {
		return;
	}
	timestamp = HAL_GetTick() + 5;

	// Main logic here
	if (emergency) {
		// TODO add emergency animation
		RGB_BreathingPattern();
		WS2812_Send();
		Set_Brightness(45);
		return;
	} else {
		switch (state) {
		case MSwait:
			if (laststate != state) {
				LEDtime = 0;
			}
			RGB_BlinkGreenTwice();
			laststate = MSwait;
			break;
		case MSidle:
			RGB_Rainbow();
			laststate = MSidle;
			break;
		case MSpick:
		case MSplace:
			laststate = MSpick;
			break;
		case MShome:
			laststate = MShome;
			break;
		case MStray:
			laststate = MStray;
			break;
		case MSpoint:
			laststate = MSpoint;
			break;
		default:
			break;
		}
	}

	for (int i = 16; i < 24; i++) {
		Set_LED(i, 0, 0, 0);
	}

	Set_Brightness(45);
	WS2812_Send();
}

void RGB_Rainbow() {
	static uint32_t startTime = 0;
	static const uint32_t transitionDuration = 5000; // Transition duration in milliseconds

	if (HAL_GetTick() - startTime >= transitionDuration) {
		startTime = HAL_GetTick();
	}

	// Calculate time elapsed in the current transition
	uint32_t elapsed = HAL_GetTick() - startTime;

	// Calculate the normalized progress (0.0 to 1.0) within the transition
	float progress = (float) elapsed / transitionDuration;

	// Calculate the hue angle based on the progress
	float hueAngle = 360.0f * progress;

	// Set LED colors based on the hue angle
	for (int i = 0; i < MAX_LED; i++) {
		// Calculate the hue value for the current LED
		float ledHue = hueAngle + (i * (360.0f / MAX_LED));

		// Convert hue to RGB using HSV color model
		float huePrime = fmodf(ledHue / 60.0f, 6.0f);
		float chroma = 1.0f;
		float x = chroma * (1.0f - fabsf(fmodf(huePrime, 2.0f) - 1.0f));

		float red, green, blue;

		if (huePrime >= 0.0f && huePrime < 1.0f) {
			red = chroma;
			green = x;
			blue = 0.0f;
		} else if (huePrime >= 1.0f && huePrime < 2.0f) {
			red = x;
			green = chroma;
			blue = 0.0f;
		} else if (huePrime >= 2.0f && huePrime < 3.0f) {
			red = 0.0f;
			green = chroma;
			blue = x;
		} else if (huePrime >= 3.0f && huePrime < 4.0f) {
			red = 0.0f;
			green = x;
			blue = chroma;
		} else if (huePrime >= 4.0f && huePrime < 5.0f) {
			red = x;
			green = 0.0f;
			blue = chroma;
		} else {
			red = chroma;
			green = 0.0f;
			blue = x;
		}

		// Scale RGB values to 0-255 range
		uint8_t r = (uint8_t) (red * 255);
		uint8_t g = (uint8_t) (green * 255);
		uint8_t b = (uint8_t) (blue * 255);

		// Set LED color
		Set_LED(i, r, g, b);
	}
}

void RGB_Bootup(void) {
	for (int i = 0; i < 60; i++) {
		Set_LED(i, 255, 0, 0);
		HAL_Delay(10);
		Set_Brightness(45);
		WS2812_Send();
	}
}

#define PULSE_PERIOD 500        // Duration of each pulse in milliseconds
void RGB_BreathingPattern() {
	if (LEDtime == 0) {
		LEDtime = HAL_GetTick();
	}

	uint32_t elapsedTime = HAL_GetTick() - LEDtime;
	uint8_t intensity;

	intensity = 128 * (1 + sinf((2 * PI * elapsedTime) / PULSE_PERIOD));

	for (int i = 0; i < MAX_LED; i++) {
		Set_LED(i, intensity, 0, 0);
	}
}

#define BLINK_DURATION 50    // Duration of each blink in milliseconds
#define INTERVAL_DURATION 50 // Duration between each blink in milliseconds
#define TOTAL_BLINKS 2        // Total number of blinks
void RGB_BlinkGreenTwice() {
	static uint32_t LEDtime = 0;
	static int blinkCount = 0;

	if (LEDtime == 0) {
		LEDtime = HAL_GetTick();
		blinkCount = 0;
	}

	uint32_t elapsedTime = HAL_GetTick() - LEDtime;

	if (blinkCount < TOTAL_BLINKS) {
		if (elapsedTime >= (blinkCount * (BLINK_DURATION + INTERVAL_DURATION))) {
			uint8_t intensity = (blinkCount % 2 == 0) ? 255 : 0;

			for (int i = 0; i < MAX_LED; i++) {
				Set_LED(i, 0, intensity, 0);
			}

			if (elapsedTime >= ((blinkCount + 1) * (BLINK_DURATION + INTERVAL_DURATION))) {
				blinkCount++;
			}
		}
	} else {
		// Stop blinking
		for (int i = 0; i < MAX_LED; i++) {
			Set_LED(i, 0, 0, 0);
		}
	}
}

#endif /* INC_RGB_H_ */
